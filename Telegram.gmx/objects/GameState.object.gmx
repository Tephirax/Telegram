<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialise variables
global.morse = false;   // Is telegraph triggered?
global.inputmorse = ''; // Dots &amp; dashes entered so far for a single letter
global.inputtext = '';  // String of text entered so far
global.sentencesubmitted = ''; // String of text accepted as sentence
global.ghosttext = '';  // String of text to be relayed back to the player

t1 = -1;                // Time since last input ended
t2 = -1;                // Time since input started
t3 = -1;                // Time after letter confirmed, before next input

dotmin = 0;             // Minimum number of frames to be considered a dot
dashmin = 10;           // Minimum number of frames to be considered a dash
resetmin = 60;          // Minimum number of frames to reset previous letter

letterconfirm = 30;     // Number of frames to wait to confirm letter
wordconfirm = 60;       // Number of frames to wait to confirm word
sentenceconfirm = 150;  // Number of frames to wait to confirm sentence
keyrelease = false;

instance_create(0, 0, obj_marker);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for input
// Handle instance where key is still pressed when deleting a letter
if ( keyrelease ) {
    if ( keyboard_check_released(vk_space) ) {
        t1 = 0;
        t2 = -1;
        t3 = -1;
        keyrelease = false;
    }
}
// Otherwise check if key is not pressed or pressed
else {
    if ( keyboard_check(vk_nokey) ) {
        global.morse = false;
        // If timer is active, check length of button press
        if ( t2 &gt;= 0 ) {
            inputtime = t2;
            show_debug_message('Button held down for ' + string(inputtime) + ' frames.');
            // Dot
            if ( inputtime &gt; dotmin &amp;&amp; inputtime &lt; dashmin ) {
                global.inputmorse = global.inputmorse + '.';
                show_debug_message('Dot');    
            }
            // Dash
            else if ( inputtime &gt;= dashmin ) {
                global.inputmorse = global.inputmorse + '-';
                show_debug_message('Dash');        
            }
        
            show_debug_message(global.inputmorse);
                
            // Reset timer t2
            t2 = -1;
            
            // Start timer t1
            t1 = 0;
        }
    }
    else if ( keyboard_check(vk_space) ) {
        global.morse = true;
        if ( t2 == -1 ) {
            // Reset timers t1 &amp; t3
            t1 = -1;
            t3 = -1;
        
            // Start timer t2
            t2 = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Advance timers &amp; reset if applicable
// t1 - Time since last input - Starts when input registered; stops when program checks for valid letter. 
// Purpose: Trigger valid letter check if t1 &gt; letterconfirm.
if ( t1 &gt;= 0 ) {
    t1++;
    // Check for end of letter
    if ( t1 &gt; letterconfirm ) {
        show_debug_message("Checking for end of letter");
        
        // Check whether inputmorse is a valid letter
        var letter = scr_checkmorse(global.inputmorse);
        // If so, append letter to inputtext
        if ( letter != '' ) {
            global.inputmorse = '';
            global.inputtext = global.inputtext + letter;
            show_debug_message("Valid letter is " + letter);
        }
        // Else reset inputmorse 
        else {
            global.inputmorse = '';
        }
        
        // Reset timers
        t1 = -1;
        t2 = -1;
        t3 = 0;
    }
}

// t2 - Time since start of input - Starts when button pressed; stops when button released. 
// Purpose: Trigger delete letter function if t2 &gt; resetmin.
if ( t2 &gt;= 0 ) {
    t2++;
    // Press &amp; hold to go back a letter
    if ( t2 &gt; resetmin ) {
        var strlen = string_length(global.inputtext);
        if ( strlen &gt; 0 ) {
            global.inputtext = string_delete(global.inputtext, strlen, 1);
            show_debug_message("Delete last character. inputtext is now: " + global.inputtext);
        }
        // Reset timer;
        t2 = -1;
        
        // Flag keyrelease = true, to prevent timer immediately refiring
        keyrelease = true;
    }
    show_debug_message(string(t2));
}

// t3 - Time since letter confirmed - Starts when valid letter registered; stops when button pressed or check runs. 
// Purpose: Trigger end of word if t3 &gt; wordconfirm.
if ( t3 &gt;= 0 ) {
    t3++;
    if ( t3 &gt; wordconfirm ) {      
        
        // Check if last letter is not a space
        var strlen = string_length(global.inputtext);
        if ( string_char_at(global.inputtext, strlen) != ' ' ) {
            show_debug_message("Checking for end of word");
            // Add space to inputtext
            if ( global.inputtext != '' ) {
                show_debug_message("Word is " + global.inputtext);
                global.inputmorse = '';
                global.inputtext = global.inputtext + ' ';
            }
            // Reset timers;
            t1 = -1;
            t2 = -1;
        }
        
        // If last letter is a space, keep timer t3 running to check for end of sentence
        if ( t3 &gt; sentenceconfirm ) {
            show_debug_message("End of sentence: " + global.inputtext);
            // Parse sentence
            scr_parse(global.inputtext);
            
            // Reset timers &amp; inputtext;
            t1 = -1;
            t2 = -1;
            t3 = -1;
            global.inputmorse = '';
            global.inputtext = '';
         
        }
        
    }   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
