<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialise variables
global.input = false;   // Is telegraph triggered by player?
global.inputmorse = ''; // Dots &amp; dashes entered so far for a single letter
global.inputtext = '';  // String of text entered so far

global.output = false;  // Is telegraph triggered by ghost?
global.outputtext = 'sos';  // String of text to be relayed back to the player
global.outputmorse = ''; // Dots &amp; dashes converted from outputtext
global.outputdelay = round(random(160)) + 80;
global.playmessage = false; // Should ghosttext be displayed
global.silence = false; // Has there been silence since the last response

t1 = -1;                // Time since last input ended
t2 = -1;                // Time since input started
t3 = -1;                // Time after letter confirmed, before next input
t4 = 0;                 // Time since all other timers were deactivated: counts up to global.ghostdelay
t5 = -1;                // Time with no input after response

dotmin = 0;             // Minimum number of frames to be considered a dot
dashmin = 10;           // Minimum number of frames to be considered a dash
resetmin = 60;          // Minimum number of frames to reset previous letter
dotoutput = 8;          // Number of frames to display as a dot
dashoutput = 18;        // Number of frames to display as a dash
interdelay = 8;         // Number of frames to leave between dots/dashes
letterdelay = 22;       // Number of frames to leave between letters (x2 between words)

letterconfirm = 30;     // Number of frames to wait to confirm letter
wordconfirm = 60;       // Number of frames to wait to confirm word
sentenceconfirm = 150;  // Number of frames to wait to confirm sentence
keyrelease = false;
nextchar = false;       // Flag to move on to next character in output

moderatesilence = 450;  // Idle text if no response is given for 15 seconds
longsilence = 900;      // Idle text if no response is given for 30 seconds
extsilence = 300;       // Idle text if no response is given every 10 seconds after 45 seconds

instance_create(0, 0, obj_marker);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset nextchar flag after displaying dash
// Use alarm twice:
// 1) When light is on, switch off light
if ( global.output ) {
    global.output = false;
    alarm[2] = interdelay;
}
// 2) When light is off, trigger next character
else {
    nextchar = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset nextchar flag after displaying dot
// Use alarm twice:
// 1) When light is on, switch off light
if ( global.output ) {
    global.output = false;
    alarm[1] = interdelay;
}
// 2) When light is off, trigger next character
else {
    nextchar = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset nextchar flag after letter delay spacing
nextchar = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for input
// Handle instance where key is still pressed when deleting a letter
if ( keyrelease ) {
    if ( keyboard_check_released(vk_space) ) {
        t1 = 0;
        t2 = -1;
        t3 = -1;
        keyrelease = false;
    }
}
// Otherwise check if key is not pressed or pressed
else {
    if ( keyboard_check(vk_nokey) ) {
        global.input = false;
        // If timer is active, check length of button press
        if ( t2 &gt;= 0 ) {
            inputtime = t2;
            show_debug_message('Button held down for ' + string(inputtime) + ' frames.');
            // Dot
            if ( inputtime &gt; dotmin &amp;&amp; inputtime &lt; dashmin ) {
                global.inputmorse = global.inputmorse + '.';
                show_debug_message('Dot');    
            }
            // Dash
            else if ( inputtime &gt;= dashmin ) {
                global.inputmorse = global.inputmorse + '-';
                show_debug_message('Dash');        
            }
        
            show_debug_message(global.inputmorse);
                
            // Reset timer t2
            t2 = -1;
            
            // Start timer t1
            t1 = 0;
        }
    }
    else if ( keyboard_check(vk_space) ) {
        global.outputtext = '';
        global.outputmorse = '';
        global.input = true;
        global.playmessage = false;
        global.silence = false;
        if ( t2 == -1 ) {
            // Reset timers t1 &amp; t3
            t1 = -1;
            t3 = -1;
            t5 = -1;
        
            // Start timer t2
            t2 = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Advance timers &amp; reset if applicable
// t1 - Time since last input - Starts when input registered; stops when program checks for valid letter. 
// Purpose: Trigger valid letter check if t1 &gt; letterconfirm.
if ( t1 &gt;= 0 ) {
    t1++;
    // Check for end of letter
    if ( t1 &gt; letterconfirm ) {
        show_debug_message("Checking for end of letter");
        
        // Check whether inputmorse is a valid letter
        var letter = scr_checkmorse(global.inputmorse);
        // If so, append letter to inputtext
        if ( letter != '' ) {
            global.inputmorse = '';
            global.inputtext = global.inputtext + letter;
            show_debug_message("Valid letter is " + letter);
        }
        // Else reset inputmorse 
        else {
            global.inputmorse = '';
        }
        
        // Reset timers
        t1 = -1;
        t2 = -1;
        t3 = 0;
        t5 = -1;
    }
}

// t2 - Time since start of input - Starts when button pressed; stops when button released. 
// Purpose: Trigger delete letter function if t2 &gt; resetmin.
if ( t2 &gt;= 0 ) {
    t2++;
    // Press &amp; hold to go back a letter
    if ( t2 &gt; resetmin ) {
        var strlen = string_length(global.inputtext);
        if ( strlen &gt; 0 ) {
            global.inputtext = string_delete(global.inputtext, strlen, 1);
            show_debug_message("Delete last character. inputtext is now: " + global.inputtext);
            global.inputmorse = '';
        }
        // Reset timer;
        t2 = -1;
        t5 = -1;
        
        // Flag keyrelease = true, to prevent timer immediately refiring
        keyrelease = true;
    }
    show_debug_message(string(t2));
}

// t3 - Time since letter confirmed - Starts when valid letter registered; stops when button pressed or check runs. 
// Purpose: Trigger end of word if t3 &gt; wordconfirm.
if ( t3 &gt;= 0 ) {
    t3++;
    if ( t3 &gt; wordconfirm ) {      
        
        // Check if last letter is not a space
        var strlen = string_length(global.inputtext);
        if ( string_char_at(global.inputtext, strlen) != ' ' ) {
            show_debug_message("Checking for end of word");
            // Add space to inputtext
            if ( global.inputtext != '' ) {
                show_debug_message("Word is " + global.inputtext);
                global.inputmorse = '';
                global.inputtext = global.inputtext + ' ';
            }
            // Reset timers;
            t1 = -1;
            t2 = -1;
        }
        
        // If last letter is a space, keep timer t3 running to check for end of sentence
        if ( t3 &gt; sentenceconfirm ) {
            show_debug_message("End of sentence: " + global.inputtext);
            // Parse sentence
            scr_parse(global.inputtext);
            
            // Reset timers &amp; inputtext;
            t1 = -1;
            t2 = -1;
            t3 = -1;
            t4 = 0;
            global.inputmorse = '';
            global.inputtext = '';
        }
    }   
}
// t4 - If all other timers are deactivated, increment t4.
// Purpose: Trigger ghost response when t4 = global.outputdelay
if ( t1 == -1 &amp;&amp; t2 == -1 &amp;&amp; t3 == -1 &amp;&amp; !global.playmessage &amp;&amp; !global.silence) {
    t4++;
    if ( t4 == global.outputdelay ) {
        show_debug_message('Start output message');
        scr_outputmorse(global.outputtext);
        nextchar = true;
        
        // Reset timer
        t4 = -1;
    }
}

// t5 - If message has been output, but no response has been given 
// after a significant period, transmit a plea for help
if ( t5 &gt;= 0 &amp;&amp; global.silence ) {
    t5++;
    if ( t5 == moderatesilence ) {
        global.outputtext = 'are you still there';
        global.outputdelay = 1;  
        global.silence = false;
        t4 = 0;    
    }
    else if ( t5 == longsilence ) {
        global.outputtext = 'oh god dont leave me here alone';
        global.outputdelay = 1;
        global.silence = false;
        t4 = 0;
    }
    else if ( t5 &gt;= moderatesilence + longsilence &amp;&amp; t5 mod extsilence == 0 ) {
        global.outputtext = 'please';
        global.outputdelay = 1;
        global.silence = false;
        t4 = 0;
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle message display if playmessage is true
if ( global.playmessage ) {
    // If ready to receive next character
    if ( nextchar ) {
        show_debug_message("Get next character");
        // Check string is at least 1 character long
        var strlen = string_length(global.outputmorse);
        show_debug_message("outputmorse string = " + global.outputmorse);
        if ( strlen &gt; 0 ) {
            // Take first character from outputmorse
            var character = string_char_at(global.outputmorse, 1);
            show_debug_message("First character is: " + character);
            // Break between letters (display nothing)
            if ( character == ' ' ) {
                alarm[0] = letterdelay;  
                show_debug_message('Break between letters');
            }
            // Dot: trigger telegraph for short period. Switched off in alarm[1] 
            else if ( character == '.' ) {
                alarm[1] = dotoutput ;
                global.output = true;
                show_debug_message('Display dot');
            }
            // Dash: trigger telegraph for longer period. Switched off in alarm[2]
            else if ( character == '-' ) {
                alarm[2] = dashoutput;
                global.output = true;
                show_debug_message('Display dash');
            }
            
            // Delete handled character from outputmorse
            global.outputmorse = string_delete(global.outputmorse, 1, 1);
            
            // Ensure next character isn't handled until applicable alarm is triggered
            nextchar = false;
        }
        // If string has length = 0, display message no further &amp; clear variables
        else {
            global.playmessage = false;
            nextchar = false;
            outputmorse = '';  
            global.outputdelay = -1; // Don't play message again
            
            // Set flag for t5 timer
            if ( t5 = -1 ) { t5 = 0; }
            global.silence = true;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
